// task 1
function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
  
  delay(3000).then(() => alert('выполнилось через 3 секунды'));

  // task 2

  let promise = new Promise(function(resolve, reject) {
    resolve(1);
  
    setTimeout(() => resolve(2), 1000);
  });
  
  promise.then(alert);

  // Вывод будет: 1.
  // Второй вызов resolve будет проигнорирован, поскольку учитывается только первый вызов reject/resolve. 
  // Все последующие вызовы – игнорируются.

// task 3 - Являются ли фрагменты кода ниже эквивалентными? 
// Другими словами, ведут ли они себя одинаково во всех обстоятельствах, для всех переданных им обработчиков?

// они не эквивалентны: pазница в том, что если ошибка произойдёт в f1, то она будет обработана в .catch в этом примере:

promise
  .then(f1)
  .catch(f2);

  // но не в этом:

  promise
  .then(f1, f2);
// Ошибка передаётся по цепочке, но во втором примере нет продолжения цепочки после f1. 
// .then передаёт результат или ошибку следующему блоку .then/catch. Так как в первом примере в цепочке далее имеется блок catch, а во втором – нет, то ошибка в нём останется необработанной.